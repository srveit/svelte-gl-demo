{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte",
    "../node_modules/@sveltejs/gl/scene/Layer.svelte",
    "../node_modules/@sveltejs/gl/scene/Overlay.svelte",
    "../node_modules/@sveltejs/gl/scene/Scene.svelte"
  ],
  "sourcesContent": [
    "<script>\n import { onMount } from 'svelte';\n import * as GL from '@sveltejs/gl';\n import Cube from './Cube.svelte';\n\n export let color = '#ff3e00';\n let w = 1;\n let h = 1;\n let d = 1;\n let radius = 0.2;\n\n const from_hex = hex => parseInt(hex.slice(1), 16);\n\n const light = {\n     x: 3,\n     y: 4.5,\n     z: 3\n };\n\n onMount(() => {\n     let frame;\n\n     const loop = () => {\n   frame = requestAnimationFrame(loop);\n\n         /* light.x = 3 * Math.sin(Date.now() * 0.001);\n          * light.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n          * light.z = 3 * Math.cos(Date.now() * 0.002);*/\n     };\n\n     loop();\n\n     return () => cancelAnimationFrame(frame);\n });\n</script>\n\n<GL.Scene>\n  <GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n  <GL.OrbitControls maxPolarAngle={Math.PI} let:location>\n    <GL.PerspectiveCamera {location} lookAt=\"center\" near={0.01} far={1000}/>\n  </GL.OrbitControls>\n\n  <GL.AmbientLight intensity={0.3}/>\n  <GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n  <!-- floor -->\n  <GL.Mesh\n    geometry={GL.plane()}\n    location={[0,-0.01,0]}\n    rotation={[-90,0,0]}\n    scale={10}\n    uniforms={{ color: 0xffffff }}\n  />\n\n\n  <Cube\n    location={[0, h/2, 0]}\n    scale={[w,h,d]}\n    radius={radius}\n    uniforms={{ color: 0x8080ff, alpha: 1.0 }}\n  />\n\n  <!-- spheres\n       <GL.Mesh\n       geometry={GL.sphere({ turns: 26, bands: 26, turns_chord: 0.25, bands_chord: 0.5 })}\n       location={[-0.5, 1.0, 1.2]}\n    scale={2.0}\n    uniforms={{ color: 0xa8ee56, alpha: 1.0 }}\n  />\n     -->\n  <!-- moving light -->\n  <GL.Group location={[light.x,light.y,light.z]}>\n\n    <GL.PointLight\n      location={[0,0,0]}\n      color={0xffffff}\n      intensity={0.6}\n    />\n  </GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n  <label>\n    <input type=\"color\" style=\"height: 40px\" bind:value={color}>\n  </label>\n\n  <label>\n    <input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1}> width ({w})\n  </label>\n\n  <label>\n    <input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1}> height ({h})\n  </label>\n\n  <label>\n    <input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1}> depth ({d})\n  </label>\n</div>\n\n<style>\n  .controls {\n    position: absolute;\n    top: 1em;\n    left: 1em;\n    background-color: rgba(255,255,255,0.7);\n    padding: 1em;\n    border-radius: 2px;\n  }\n</style>\n",
    "<script>\n\timport { get_layer, set_layer } from '../internal/index.mjs';\n\n\texport let index = undefined;\n\n\tset_layer(get_layer().add_child(index));\n</script>\n\n<div class=\"layer\">\n\t<slot></slot>\n</div>\n\n<style>\n\t/* for overlays, create a stacking context */\n\t.layer {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n</style>",
    "<script>\n\timport Point from './Point.svelte';\n\n\texport let location;\n\texport let direction;\n\texport let snap;\n\n\t$: px = n => `${snap ? Math.round(n) : n}px`;\n</script>\n\n<Point {location} {direction} let:x let:y let:vector>\n\t<span\n\t\tclass=\"overlay\"\n\t\tstyle=\"transform: translate({px(x)}, {px(y)})\"\n\t>\n\t\t<slot vector={vector}></slot>\n\t</span>\n</Point>\n\n<style>\n\t.overlay {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\tuser-select: none;\n\t\t-moz-user-select: none;\n\t}\n</style>",
    "<script context=\"module\">\n\timport { readable } from 'svelte/store';\n\n\tfunction is_intersecting(el) {\n\t\t// TODO this shouldn't be necessary. But the initial value\n\t\t// of entry.isIntersecting in an IO can be incorrect, it\n\t\t// turns out? need to investigate further\n\t\tconst bcr = el.getBoundingClientRect();\n\n\t\treturn (\n\t\t\tbcr.bottom > 0 &&\n\t\t\tbcr.right  > 0 &&\n\t\t\tbcr.top    < window.innerHeight &&\n\t\t\tbcr.left   < window.innerWidth\n\t\t);\n\t}\n\n\tfunction get_visibility(node) {\n\t\treturn readable(false, set => {\n\t\t\tif (typeof IntersectionObserver !== 'undefined') {\n\t\t\t\tconst observer = new IntersectionObserver(entries => {\n\t\t\t\t\t// set(entries[0].isIntersecting);\n\t\t\t\t\tset(is_intersecting(node));\n\t\t\t\t});\n\n\t\t\t\tobserver.observe(node);\n\t\t\t\treturn () => observer.unobserve(node);\n\t\t\t}\n\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tfunction handler() {\n\t\t\t\t\tconst { top, bottom } = node.getBoundingClientRect();\n\t\t\t\t\tset(bottom > 0 && top < window.innerHeight);\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('scroll', handler);\n\t\t\t\twindow.addEventListener('resize', handler);\n\n\t\t\t\treturn () => {\n\t\t\t\t\twindow.removeEventListener('scroll', handler);\n\t\t\t\t\twindow.removeEventListener('resize', handler);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n</script>\n\n<script>\n\timport { setContext, onMount, onDestroy, tick } from 'svelte';\n\timport { writable } from 'svelte/store';\n\timport { RENDERER, LAYER, PARENT, CAMERA, create_layer } from '../internal/index.mjs';\n\timport { create_worker, process_color } from '../internal/utils.mjs';\n\timport * as mat4 from 'gl-matrix/mat4';\n\timport * as vec3 from 'gl-matrix/vec3';\n\n\texport let background = [1, 1, 1];\n\texport let backgroundOpacity = 1;\n\texport let fog = undefined;\n\texport let pixelRatio = undefined;\n\n\tconst use_fog = 'fog' in $$props;\n\n\t$: bg = process_color(background);\n\n\tlet canvas;\n\tlet visible = writable(false);\n\tlet pending = false;\n\tlet w;\n\tlet h;\n\n\tlet gl;\n\tlet draw;\n\tlet camera_stores = {\n\t\tcamera_matrix: writable(),\n\t\tview: writable(),\n\t\tprojection: writable()\n\t};\n\n\tconst invalidate = typeof window !== 'undefined'\n\t\t? () => {\n\t\t\tif (!update_scheduled) {\n\t\t\t\tupdate_scheduled = true;\n\t\t\t\tresolved.then(draw);\n\t\t\t}\n\t\t}\n\t\t: () => {};\n\n\tconst width = writable(1);\n\tconst height = writable(1);\n\n\tconst root_layer = create_layer(0, invalidate);\n\n\tconst default_camera = { /* TODO */ };\n\tlet camera = default_camera;\n\tconst num_lights = 8;\n\n\tconst meshes = [];\n\n\t// lights\n\tconst lights = {\n\t\tambient: [],\n\t\tdirectional: [],\n\t\tpoint: []\n\t};\n\n\tlet update_scheduled = false;\n\tlet resolved = Promise.resolve();\n\n\tfunction add_to(array) {\n\t\treturn fn => {\n\t\t\tarray.push(fn);\n\t\t\tinvalidate();\n\n\t\t\tonDestroy(() => {\n\t\t\t\tconst i = array.indexOf(fn);\n\t\t\t\tif (~i) array.splice(i, 1);\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t}\n\t}\n\n\tconst targets = new Map();\n\tlet camera_position_changed_since_last_render = true;\n\n\tconst scene = {\n\t\tdefines: [\n\t\t\t`#define NUM_LIGHTS 2\\n` + // TODO configure this\n\t\t\t`#define USE_FOG ${use_fog}\\n`\n\t\t].join(''),\n\n\t\tadd_camera: _camera => {\n\t\t\tif (camera && camera !== default_camera) {\n\t\t\t\tthrow new Error(`A scene can only have one camera`);\n\t\t\t}\n\n\t\t\tcamera = _camera;\n\t\t\tinvalidate();\n\n\t\t\t// TODO this is garbage\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\t\t\tcamera_stores.view.set(camera.view);\n\n\t\t\tonDestroy(() => {\n\t\t\t\tcamera = default_camera;\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t},\n\n\t\tupdate_camera: camera => {\n\t\t\t// for overlays\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.view.set(camera.view);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\n\t\t\tcamera_position_changed_since_last_render = true;\n\t\t\tinvalidate();\n\t\t},\n\n\t\tadd_directional_light: add_to(lights.directional),\n\t\tadd_point_light: add_to(lights.point),\n\t\tadd_ambient_light: add_to(lights.ambient),\n\n\t\tget_target(id) {\n\t\t\tif (!targets.has(id)) targets.set(id, writable(null))\n\t\t\treturn targets.get(id);\n\t\t},\n\n\t\tinvalidate,\n\n\t\t...camera_stores,\n\n\t\twidth,\n\t\theight\n\t};\n\n\tsetContext(RENDERER, scene);\n\tsetContext(LAYER, root_layer);\n\n\tconst origin = mat4.identity(mat4.create());\n\tconst ctm = writable(origin);\n\tsetContext(PARENT, {\n\t\tget_matrix_world: () => origin,\n\t\tctm: { subscribe: ctm.subscribe }\n\t});\n\n\tonMount(() => {\n\t\tscene.canvas = canvas;\n\t\tgl = scene.gl = canvas.getContext('webgl');\n\t\tvisible = get_visibility(canvas);\n\n\t\tconst extensions = [\n\t\t\t'OES_element_index_uint',\n\t\t\t'OES_standard_derivatives'\n\t\t];\n\n\t\textensions.forEach(name => {\n\t\t\tconst ext = gl.getExtension(name);\n\t\t\tif (!ext) {\n\t\t\t\tthrow new Error(`Unsupported extension: ${name}`);\n\t\t\t}\n\t\t});\n\n\t\tdraw = force => {\n\t\t\tif (!camera) return; // TODO make this `!ready` or something instead\n\n\t\t\tif (dimensions_need_update) {\n\t\t\t\tconst DPR = pixelRatio || window.devicePixelRatio || 1;\n\t\t\t\tcanvas.width = $width * DPR;\n\t\t\t\tcanvas.height = $height * DPR;\n\t\t\t\tgl.viewport(0, 0, $width * DPR, $height * DPR);\n\n\t\t\t\tdimensions_need_update = false;\n\t\t\t}\n\n\t\t\tupdate_scheduled = false;\n\n\t\t\tif (!$visible && !force) {\n\t\t\t\tpending = true;\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\tpending = false;\n\n\t\t\tgl.clearColor(...bg, backgroundOpacity);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\tgl.enable(gl.CULL_FACE);\n\t\t\tgl.enable(gl.BLEND);\n\n\t\t\t// calculate total ambient light\n\t\t\tconst ambient_light = lights.ambient.reduce((total, { color, intensity }) => {\n\t\t\t\treturn [\n\t\t\t\t\tMath.min(total[0] + color[0] * intensity, 1),\n\t\t\t\t\tMath.min(total[1] + color[1] * intensity, 1),\n\t\t\t\t\tMath.min(total[2] + color[2] * intensity, 1)\n\t\t\t\t];\n\t\t\t}, new Float32Array([0, 0, 0]));\n\n\t\t\tlet previous_program;\n\n\t\t\tfunction render_mesh({ model, model_inverse_transpose, geometry, material }) {\n\t\t\t\t// TODO should this even be possible?\n\t\t\t\tif (!material) return;\n\n\t\t\t\tif (material.depthTest !== false) {\n\t\t\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t\t\t} else {\n\t\t\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\t\t}\n\n\t\t\t\tgl.blendFuncSeparate(\n\t\t\t\t\tgl.SRC_ALPHA, // source rgb\n\t\t\t\t\tgl.ONE_MINUS_SRC_ALPHA, // dest rgb\n\t\t\t\t\tgl.SRC_ALPHA, // source alpha\n\t\t\t\t\tgl.ONE // dest alpha\n\t\t\t\t);\n\n\t\t\t\tif (material.program !== previous_program) {\n\t\t\t\t\tprevious_program = material.program;\n\n\t\t\t\t\t// TODO move logic to the mesh/material?\n\t\t\t\t\tgl.useProgram(material.program);\n\n\t\t\t\t\t// set built-ins\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.AMBIENT_LIGHT, ambient_light);\n\n\t\t\t\t\tif (use_fog) {\n\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.FOG_COLOR, bg);\n\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.FOG_DENSITY, fog);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.DIRECTIONAL_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.directional[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].direction, light.direction);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.DIRECTIONAL_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.POINT_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.point[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].location, light.location);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.POINT_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.CAMERA_WORLD_POSITION, camera.world_position);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.VIEW, false, camera.view);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.PROJECTION, false, camera.projection);\n\t\t\t\t}\n\n\t\t\t\t// set mesh-specific built-in uniforms\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL, false, model);\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL_INVERSE_TRANSPOSE, false, model_inverse_transpose);\n\n\t\t\t\t// set material-specific built-in uniforms\n\t\t\t\tmaterial.apply_uniforms(gl);\n\n\t\t\t\t// set attributes\n\t\t\t\tgeometry.set_attributes(gl);\n\n\t\t\t\t// draw\n\t\t\t\tif (geometry.index) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.buffers.__index);\n\t\t\t\t\tgl.drawElements(gl[geometry.primitive], geometry.index.length, gl.UNSIGNED_INT, 0);\n\t\t\t\t} else {\n\t\t\t\t\tconst primitiveType = gl[geometry.primitive];\n\t\t\t\t\tgl.drawArrays(primitiveType, 0, geometry.count);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction render_layer(layer) {\n\t\t\t\tif (layer.needs_sort) {\n\t\t\t\t\tlayer.child_layers.sort((a, b) => a.index - b.index);\n\t\t\t\t\tlayer.needs_sort = false;\n\t\t\t\t}\n\n\t\t\t\tgl.depthMask(true);\n\t\t\t\tgl.clearDepth(1.0);\n\t\t\t\tgl.clear(gl.DEPTH_BUFFER_BIT);\n\n\t\t\t\tfor (let i = 0; i < layer.meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.meshes[i]);\n\t\t\t\t}\n\n\t\t\t\t// TODO sort transparent meshes, furthest to closest\n\t\t\t\tgl.depthMask(false);\n\n\t\t\t\tif (camera_position_changed_since_last_render || layer.needs_transparency_sort) {\n\t\t\t\t\tsort_transparent_meshes(layer.transparent_meshes);\n\t\t\t\t\tlayer.needs_transparency_sort = false;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.transparent_meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.transparent_meshes[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.child_layers.length; i += 1) {\n\t\t\t\t\trender_layer(layer.child_layers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender_layer(root_layer);\n\t\t\tcamera_position_changed_since_last_render = false;\n\t\t};\n\n\t\t// for some wacky reason, Adblock Plus seems to prevent the\n\t\t// initial dimensions from being correctly reported\n\t\tconst timeout = setTimeout(() => {\n\t\t\t$width = canvas.clientWidth;\n\t\t\t$height = canvas.clientHeight;\n\t\t});\n\n\t\ttick().then(() => draw(true));\n\n\t\treturn () => {\n\t\t\tgl.getExtension('WEBGL_lose_context').loseContext();\n\t\t\tclearTimeout(timeout);\n\t\t};\n\t});\n\n\tconst sort_transparent_meshes = meshes => {\n\t\tif (meshes.length < 2) return;\n\n\t\tconst lookup = new Map();\n\t\tconst out = new Float32Array(16);\n\n\t\tmeshes.forEach(mesh => {\n\t\t\tconst z = mat4.multiply(out, camera.view, mesh.model)[14];\n\t\t\tlookup.set(mesh, z);\n\t\t});\n\n\t\tmeshes.sort((a, b) => lookup.get(a) - lookup.get(b));\n\t};\n\n\tlet dimensions_need_update = true;\n\n\tconst update_dimensions = () => {\n\t\tdimensions_need_update = true;\n\t\tinvalidate();\n\t};\n\n\t$: ($width, $height, update_dimensions());\n\t$: (background, backgroundOpacity, fog, scene.invalidate());\n\t$: if ($visible && pending) scene.invalidate();\n</script>\n\n<style>\n\t.container, canvas {\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: block;\n\t\toverflow: hidden;\n\t}\n</style>\n\n<div class=\"container\" bind:clientWidth={$width} bind:clientHeight={$height}>\n\t<canvas bind:this={canvas}></canvas>\n\n\t{#if gl}\n\t\t<slot width={$width} height={$height}></slot>\n\t{/if}\n</div>"
  ],
  "names": [],
  "mappings": "AAqGE,SAAS,cAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,GAAG,CACT,gBAAgB,CAAE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACvC,OAAO,CAAE,GAAG,CACZ,aAAa,CAAE,GAAG,AACpB,CAAC;AC9FF,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,AACR,CAAC;ACED,QAAQ,cAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,WAAW,CAAE,IAAI,CACjB,gBAAgB,CAAE,IAAI,AACvB,CAAC;ACkXD,wBAAU,CAAE,MAAM,cAAC,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,MAAM,AACjB,CAAC"
}